# 1과목 요구사항 확인

## 1.디자인 패턴 ★★★

- 소프트웨어 설계시 자주 쓰이는 방법을 정리한 패턴. 생성, 구조, 행위로 분류

### 1) 생성 패턴(creational Pattren) : 객체 인스턴스 생성에 관여

- 추상 팩토리 패턴(Abstract Factory)
  - 구체적인 클래스에 의존하지 않고, 연관된 객체들을 그룹으로 생성
- 빌더 패턴(Builder)
  - 객체를 조립하여 생성
  - 생성과 구현 분리해서 복잡한 객체를 생성
- 팩토리 메소드 패턴(Factory Method)
  - 상위 클래스에서 인터페이스 정의하고, 서브 클래스가 실제 생성
  - 부모(상위) 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴, 자식(하위) 클래스가 어떤 객체를 생성할지 결정하도록 하는 패턴, 부모(상위) 클래스 코드에 구체 클래스 이름을 감추기 위한 방법으로도 사용
- 프로토타입 패턴(Prototype)
  - prototype을 먼저 생성하고 이를 복제하여 객체를 생성
- 싱글톤 패턴(Singleton)
  - 객체의 인스턴스는 오직 하나. 하나의 객체를 생성해 어디든 참조할 수 있으나 동시 참조 불가

### 2) 구조 패턴(Structural Pattern) : 여러 객체를 모아 구조화시키는 패턴

- 어댑터 패턴(Adapter)
  - 기존 클래스 재사용할 수 있도록 중간에서 맞춰준다.
  - 호환성 없는 클래스의 인터페이스를 이용할 수 있게 변환
- 브리지 패턴(Bridge)
  - 구현부에서 추상 계층 분리하여 결합도를 낮춘 패턴 (기능과 구현을 두 개의 별도 클래스로 구현)
- 컴포지트 패턴(Composite)
  - 객체들의 관계를 트리 구조로 구성
  - 복합 객체와 단일 객체를 동일하게 취급
- 데코레이터 패턴(Decorator)
  - 상속을 사용하지 않고도 객체의 기능을 동적으로 확장 (상속의 대안)
  - 객체 결합을 통해 기능 확장
- 퍼싸드 패턴(Facade)
  - 복잡한 시스템에 단순한 인터페이스를 제공, 접근성을 높인 패턴 ex) 리모컨
- 플라이웨이트 패턴(Flyweight)
  - 객체를 공유해서 사용함으로써 메모리 절약하는 패턴
- 프록시 패턴(Proxy)
  - 접근이 어려운 객체를 연결해주는 인터페이스 역할을 수행하는 패턴

### 3) 행위 패턴(Behavioral Pattern) : 클래스나 객체들의 상호작용 패턴화

- 책임 연쇄 패턴(Chain of Responsibility)

  - 한 객체가 요청을 처리하지 못하면 다음 객체로 넘어가는 패턴
  - 한 요청을 2 개 이상의 객체에서 처리

- 방문자 패턴(Visitor)

  - 필요한 기능은 해당 클래스에 방문해서 처리하는 패턴
  - 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장

- 커맨드 패턴(Command)

  - 요청을 객체로 캡슐화하여, 요청이 들어오면 그에 맞는 서브 클래스 실행

- 반복자 패턴(Iterator)

  - 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴(내부 노출 없이 순차적 접근 가능)
  - 내부구조를 노출하지 않고, 복합 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴

- 메멘토 패턴(Memento)

  - 객체를 해당 시점의 상태로 되돌릴 수 있는 기능을 제공하는 패턴(Ctrl+z)

- 옵저버 패턴(Observer)

  - 관찰대상의 변화를 탐지
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신, 일 대 다(one-to-many) 의존성을 가진다.
  - 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합(Loose coupling)하는 디자인을 사용

- 템플릿 메소드 패턴(Template Method)

  - 상위 클래스에서는 기능 골격을 정의, 하위 클래스에서 세부 처리 방법을 구체화

  > 팩토리 메소드 - 상위 클래스에서 인터페이스 정의 후, 하위 클래스에서 실제 생성

- 상태 패턴(State)

  - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
  - 객체의 상태를 캡슐화하고, 이를 참조해 동작을 다르게 처리

- 전략 패턴(Strategy)

  - 클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하는 패턴
  - 동일한 계열의 알고리즘을 캡슐화하고, 전략을 선택해 사용
  - 행위를 클래스로 캡슐화해 동적으로 햏위를 자유롭게 변환

- 인터프리터 패턴(Interpreter)

  - 여러 언어 구문을 해석할 수 있게 해주는 패턴

- 중재자 패턴(Mediator)

  - 객체 사이에 중재자를 두어 의존성을 줄이는 패턴

## 객체지향 ★

### 객체지향 용어

- 객체(Object) : 실세계에 존재하거나 생각할 수 있는 것
- 클래스(Class) : 유사한 객체들을 묶어서 하나의 공통된 특성을 표현
- 인스턴스(Instance) : 같은 클래스에 속한 각각의 객체
- 메서드(Method) : 클래스로부터 생성된 객체를 사용하는 방법
- 메시지(Message) : 객체에게 어떤 행위를 하도록 지시하는 명령
- 캡슐화(Encapsulation) : 데이터와 함수를 하나로 묶는 것(정보 은닉)
- 정보 은닉(Information Hiding) : 객체의 속성과 오퍼레이션의 일부를 감춰서 객체 외부에서는 접근이 불가능
- 상속(Inheritance) : 상위 클래스의 속성과 연산을 하위 클래스가 물려받는 것
- 다형성(Polymorphism) : 상속받은 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있다.
- 추상화(Abstraction) : 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시키는 것
- 집단화(Aggregation) : 클래스 사이의 전체(Part-whole) 또는 부분(is-a-part-of) 같은 관계
- 일반화(Generalization) : 클래스가 다른 클래스를 포함하는 상위 개념이면, is-a 관계, 일반화 관계로 모델링

### 객체지향 설계 원칙 #SOLID

- SRP (단일 책임 원칙, Single Responsibility) : 객체는 단 하나의 책임만 가져야 한다.
- OCP(개방-폐쇄 원칙, Open-Closed) : 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- LSP (리스코프 치환 원칙, Liskov Substitution) : 상속받은 하위 클래스는 언제나 상위클래스로 교체 가능
- ISP(인터페이스 분리원칙, Interface Segregation) : 클라이언트는 미사용 메서드와 의존관계를 맺으면 안된다.
- DIP (의존역전 원칙, Dependency Inversion Principle) : 의존 관계를 맺을 때, 변화하기 어려운 것에 의존

### 럼바우의 객체지향 분석 기법

- 객체 모델링(Object/Information Modeling) : 객체 다이어그램(정보 모델링) => 구조 - 예) ER다이어그램(ERD)
- 동적 모델링(Dynamic Modeling) : 상태 다이어그램(상태도) => 시간에 따라 변하는 것 - 예) 상태 변화도

- 기능 모델링(Function Modeling) : 자료 흐름도(DFD) => 입력값이 출력값일 때 - 예) 자료 흐름도(DFD)

### 상향식 비용 산정 기법 ★

1) LOC 기법 (원시 코드 라인 수, Line Of Code)
   - 원시 코드 라인수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이것으로 비용을 산정하는 기법
   - Loc 기법으로 개발 해야 하는 프로젝트의 총 라인이 30000 라인이고, 개발자가 5 명, 그리고 인당 월 평균 300 라인의 개발이 가능할 때, 소요되는 예상 시간의 계산식과 결과는? (30000 / 5) / 300 = 20 개월
2) Man Month
   - 한 사람이 1개월간 할 수 있는 일의 양을 기준으로 비용 산정
   - Man Month = (LoC) / 개발자의 월간 생산성
   - 프로젝트 기간 = (Man Month) / 프로젝트 인력
   - Loc가 50,000 라인이고, 개발자가 10명이며 개발자는 월평균 250라인을 개발할 경우 Man Month = 200
3) COCOMO(consturctive Cost Model) 모형
   - 보헴(Boehm) 제안. 프로그램 규모에 따라 비용 산정
   - 비용산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)으로 산정

> COCOMO 소프트웨어 개발유형
>
> - 조직형 Organic : 5 만 (50KDSI) 라인 이하 소프트웨어 개발(소규모)
> - 반분리형 Semi-Detached : 30 만(300KDSI) 라인 이하 소프트웨어를 개발 (중간 규모)
> - 내장형 Embedded : 30 만(300KDSI) 라인 이상의 소트웨어 개발(대규모)
>
> COCOMO 모형의 종류
>
> - 기본형 COCOMO (Basic) : 코드 라인 수, 개발 유형을 이용하여 비용 산정
> - 중간형 COCOMO (Intermediate) : 기본형 COCOMO 기반. 15가지 요인에 의해 비용 산정
> - 발전형 COCOMO (Detailed) : 중간형 COCOMO 보완. 개발 공정별로 명확하게 노력을 산출하여 비용 산정

4) Putnam 모형

   - Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정기법

   - 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정

   - 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력 감소

     SLIM : Purnam 모형을 기초로 해서 만든 자동화 추정 도구

5) 기능 점수(FP : Functional Point) 모형

   - 알브레히트(Albrecht) 제안

   - 요구 기능을 증가시키는 요인별로 가중치 부여. 요인별 가중치를 합산, 총 기능점수 계산 비용 산정

     ESTIMACS : 다양한 프로젝트와 개ㅐ인별 요소를 수용하도록 FP 모형을 기초로 개발된 자동화 추정 도구

### 하향식 비용 산정 기법

- 과거의 유사한 경험을 바탕을 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정, 비과학적 방법

1) 전문가 감정 기법 : 조직 내 경험이 많은 전문가들에게 비용 산정을 의뢰(개인적, 주관적)
2) 델파이 기법 : 주관적인 편견 보완. 한명의 조정자와 여러 전문가의 의견을 종합하여 산정

### 일정 관리 모델

1) CPM(주 공정법) : 여러 작업의 수행 순서가 얽힌 프로젝트에서 일정 계산(임계 경로 계산법 : 가장 긴 경로)
2) CCPM (중요 연쇄 공정법) : 주 공정법의 연쇄법, 자원 제약을 고려하여 일정 계산
3) PERT : 낙관치.중관치.비관치의 3점 추정방식으로 일정 관리

### 요구사항 개발 프로세스

- 요구사항의 유형

  1) 기능적 요구사항 : 시스템이 제공하는 기능, 서비스에 대한 요구사항 (입출력, 연산, DB, 통신 기능 등)
  2) 비기능적 요구사항 : 시스템이 수행하는 기능 이외의 사항 (제약사항, 품질, 성능, 보안)
  3) 사용자 요구사항 : 사용자 관점에서 본 시스템이 제공해야할 요구사항
  4) 시스템 요구사항 : 개발자 관점에서 본 시스템이 제공해야 할 요구사항

- 요구 사항 개발 프로세스 : 도출(Elictation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)

  1) 요구사항 도출(Requirement Elictiation)
     - 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계
     - 요구사항 도출 기법 : 청취와 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스, 롤 플레잉
  2) 요구사항 분석(Requirement Analysis)
     - 요구사항 정의 문서화, 타당성 조사, 비용과 일정에 대한 제약설정
     - 요구사항 분석에 사용되는 대표적인 도구 : 자료 흐름도(DFD), 자료 사전(DD)
  3) 요구사항 명세(Requirements Specification)
     - 정형 명세기법(수학적 기반) : Z, VDM, Petri-Net, CSP, CCS, LOTOS
     - 비정형 명세기법(자연어 기반) : FSM, Decision Table, ER 모델링, State Chart(SADT), UseCase
     - 정형 명세 기법은 사용자의 요구를 표현할 때 수학적인 원리와 표기법을 이용
     - 비정형 명세 기법은 사용자의 요구를 표현할 때 자연어를 기반으로 서술
  4) 요구사항 확인(Requirements Validation)
     - 요구사항이 고객이 정말 원하는 시스템을 제대로 정의하고 있는지 점검
     - 인터페이스 요구사항 검토 계획 수립 -> 검토 및 오류 수정 -> 베이스라인 설정

- 요구사항 검증 방법

  - 정형 기술 검토(TCR)
    - 동료 검토(Peer Review) : 작성자가 설명하고, 이해관계자들이 설명을 들으며 결함 발견
    - 워크 스루(Walk Through) : 검토자료 사전 배포 후 짧은 회의 진행
    - 인스펙션(Inspection) : 저자 제외한 다른 전문가가 검토
  - 프로토타이핑 활용
  - 테스트 케이스를 통한 확인
  - CASE 도구 활용
  - 베이스라인 검증
  - 요구사항 추적표(RTM) 검증

- 요구 공학(Requirements Engineering) : 요구사항을 정의하고 분석 및 관리하는 프로세스를 연구하는 학문

- 소프트웨어 공학(SE, Software Engineering) : 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문

- 테일러링 : SW 개발 프로세스, 기법 등을 수정 보완하여 비즈니스/기술적 요구에 최적화

- 요구공학 프로세스

  - 요구공학 개발 단계 (CMM Level 3)

    1. 도출 : 이해관계자 식별, 고객 분석
    2. 분석 : 분류 -> 개념 모델링 생성 -> 할당 ->협상 -> 분석
    3. 명세 : 정형화된 형태로 명세 작성
    4. 확인 : 요구사항 이해를 확인하고 문서가 완전한지 검증

  - 요구공학 개발 단계 (CMM Level 2)

    1. 협상 : 구현 가능한 기능 협상

    2. 기준선 설정 : 기준선(베이스라인) 설정

    3. 변경관리 : 형상통제 위원회를 운영하여 변경 관리

       CCB : 형상 관리의 방침을 정하고 산출물을 검토하는 조직

       베이스라인 : 개발 과정의 산출물의 변화를 통제하는 시점

    4. 확인 및 검증 : 요구사항에 부합하는지 확인

- 페르소나 : 잠재적 사용자와 다양한 목적과 관찰된 행동 패턴을 응집시켜놓은 가상의 사용자
- 요구사항 매트릭스 : 페르소나의 목적을 기준으로 데이터 요구, 기능의 기반으로 만든 요구사항 표
- 3C 분석(고객/경쟁사/자가 분석), SWOT(강점/약점/기회/위협 분석), 목업(와이어프레임보다 더 시제처럼)

### 구조적 분석 기법(DFD, DD)

- 자료의 흐름/처리를 중심으로 하는 요구사항 분석 방법
- 구조적 분석 기법 도구 : 자료흐름도(DFD), 자료사전(DD), 소단위 명세서, 개체 관계도(ERD), 상태 전이도(STD)

#### DFD (자료 흐름도, Data Flow Diagram) = 버블(bubble) 차트

- 요구사항 분석에서 자료의 흐름/처리를 도형 중심으로 기술하는 방법

> 자료 흐름도의 구성요소
>
> - 프로세스(Process) => 원으로 표시. 자료를 변환시키는 시스템의 한 부분 (처리 과정)
> - 자료 흐름(Data Flow) => 화살표로 표시. 자료의 이동(흐름)을 나타냄
> - 자료 저장소(Data Store) => 평행선으로 표시. 시스템에서의 자료 저장소(파일, DB)
> - 단말(Terminator) => 사각형으로 표시. 시스테모가 교신하는 외부 개체

#### DD (자료 사전, Data Dictionary)

- 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것(메타 데이터)

> 자료사전 기호
>
> =: 자료의 정의 (is composed of) ~로 구성되어 있다
>
> +: 자료의 연결 (and) 그리고
>
> (): 자료의 생략 (optional) 생량 가능한 자료
>
> []: 자료의 선택 (or) 또는
>
> {} : 자료의 반복 (Itertaion of) 자료의 반복
>
> **: 자료의 설명(comment) 주석

### 소프트웨어 생명주기(SDLC)

- 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차

#### 대표적인 생명주기 모형

1. 폭포수 모델(Waterfall Model)
   - 고전적 생명주기 모형, 선형 순차적 모델
   - 단계별 정의 , 개발 도중 요구사항의 변경 어려움
   - 타당성 검토, 계획, 요구사항 분석, 구현, 테스트 유지보수의 단계를 통해 소프트웨어를 개발
2. 프로토타입 모델(Prototype Model, 원형 모형)
   - 견본(시제)품을 만들어 최종 결과물을 예측하는 모형
   - 발주자나 개발자 모두에게 공동의 참조모델을 제공
   - 개발 단계 안에서 유지보수가 이루어지는 것으로 볼 수 있다.
   - 요구사항의 충실 반영
3. 나선형 모델(Spiral Model, 점진적 모형)
   - 폭포수 모형 + 프로토타입 모형에서 "위험 분석" 기능 추가(보헴이 제안)
   - 점진적인 개발 과정 반복으로, 요구사항 추가 가능, 유지보수 과정 필요 X
   - 비교적 대규모 시스템에 적합
   - 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가
4. 반복적 모델(Interation Model)
   - 구축대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점증 완성시키는 모델(증분적)

Secure SDLC : 보안 소프트웨어 개발 생명 주기

### 소프트웨어 개발 방법론

1. 구조적 방법론
   - 전체 시스템을 나눠 개발하고 통합하는 분할,정복 방식 나씨-슈나이더만 차트 사용
2. 정보공학 방법론
   - 정보 시스템 개발에 필요한 절차를 체계화 (대형 프로젝트)
3. 객체 지향 방법론
   - 객체라는 단위로 시스템을 설계
4. 컴포넌트 기반 방법론 (CBD, Component Based Development)
   - 컴포넌트를 조립해 작성
   - 생산성과 품질을 높이고, 유지보수 비용을 최소화
5. 애자일 방법론 (Agile)
   - 계획을 따르기보다는 변화에 대응하는 것에 더 가치
   - 고객과의 의사소통, 고객과의 협업, 개인과 소통을 중요하게 생각
   - 예_ XP, 스크럽(Scrum), 칸반(Kanban), 크리스탈(Crystal), 린(LEAN), 기능 주도 개발(FDD)
   - 고객 요구사항 변화에 유연하게 대응하기 위해 일정한 주기를 반복하면서 개발 고객에게 시제품을 지속적으로 제공, 고객의 요구사항이 정확하게 반영되고 있는지 점검. 폭포수 모형에 대비되는 유연한 방법본, 비교적 소규모 개발 프로젝트에서 각광받고 있는 개발 방법론
6. 제품 계열 방법론(Product Line Development)
   - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론 (임베디드 소프트웨어 작성에 유용)

### XP(eXtream Programming)

- 고객의 참여와 릴리즈 기간을 짧고 반복을 극대화하여 개발 생산성을 향상

XP의 핵심 가치 : 용기(Courage), 의사소통(Communication), 피드백(Feedback), 존중(Respect), 단순성(Simplictiy)

XP의 기본원리

- Continuous Intergration(지속적인 통합, CI) : 모듈 단위로 개발된 코드들은 작업이 마무리 될 때 지속적 통합
- Collective Ownership(공동 소유권) : 개발 코드에 대한 권한과 책임을 공동 소유
- Pair Programming(짝 프로그래밍) : 다른 사람과 페어로 개발하여 공동 책임
- Whole Team(전체 팀) : 모든 구성원은 각자 역할이 있고 책임
- Small Releases(소규모 릴리즈) : 릴리즈 기간을 짧게 반복함으로써 , 고객의 요구 변화에 신속하게 대응
- Test-Driven Devleopment(테스트 주도 개발) : 먼저 테스트 케이스를 작성, 통과할 만한 코드를 작성
- Refactoring(리팩토링) : 기능의 변경 없이 시스템을 재구성 (중복 제거, 단순화, 유연성 강화)
- Metaphor(메타포어) : 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자간 의사소통을 원활

XP 프로세스

1. 릴리즈 계획 수립 : 부분 혹은 전체 개발 완료 시점에 대한 일정을 수립
2. 이터레이션 : 실제 개발 작업을 진행. 1~3주 정도의 기간 내에서 진행
3. 승인 검사(인수 테스트) : 하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트
4. 소규모 릴리즈 : 요구사항에 유연 대응하도록 릴리즈의 규모를 축소

### 스크럼(Scrum)

- 팀이 중심이 되어 매일 정해진 시간, 장소에서 짧은 시간 개발하는 방법론

Scrum 프로세스

- 백로그(Backlog) : 프로젝트에 대한 요구사항
- 스프린트(Sprint) : 실제 개발 작업 진행, 2~4주 정도의 기간 내에서 진행
- 스크럼 미팅(데일리 미팅) : 매일 15분 정도 미팅으로 To-Do List 계획수립 및 번 다운 차트 작성
- 스크럼 마스터 : 프로젝트 리터, 스크럼 수행 시 문제를 인지 및 해결하는 사람
- 스프린트 회고 : 스프린트 주기를 되돌아보며 규칙 준수 여부, 개서넘을 확인하고 기록
- 번 다운 차트(Burn Down Chart) : 남은 작업 시간을 그래픽적으로 표현한 차트

### 현행 시스템 파악 절차

1. 시스템 구성 파악 : 기간(중요) 업무와 지원 업무로 구분하여 기술
2. 시스템 기능 파악 : 기능을 주요, 하부, 세부 기능으로 구분, 계층형으로 표시
3. 시스템 인터페이스 파악 : 단위 업무 시스템 간 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 파악
4. 아키텍쳐 구성 파악 : 최상위 수준에서 계층별로 표현한 아키텍처 구성도를 작성
5. 소프트웨어 구성 파악: 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이선스 수 파악
6. 하드웨어 구성 파악 : 단위 업무 시스템들이 운용되는 서버의 주요 사양, 수량, 이중화 적용 여부 파악
7. 네트워크 구성 파악 : 서버의 위치, 서버간의 네트워크 연결 방식을 네트워크 구성도로 작성

### 요구사항 분석 CASE,HIPO

- 요구사항 분석용 CASE(자동화 도구) : 요구사항 자동 분석하여 요구사항 분석 명세서를 기술 할 수 있는 도구
- 대표적인 요구사항 분석용 CASE: SADT,SREM,PSL/PAS, TAGS

CASE의 주요 기능

- 그래픽 지원 / 소프트웨어 생명주기 전 단계의 연결/ 다양한 소프트웨어 개발 모형 지원 / 모델들 사이의 모순검사 / 오류검증 / 자료흐름도 등 다이어그램 작성 / 시스템 문서화 및 명세화를 위한 그래픽 지원

CASE 도구의 분류

1. 상위 CASE 도구 : 요구분석, 설계 단계를 지원
   - 모델들 사이의 모순 검사 기능, 모델의 오류검증 기능, 자료 흐름도의 작성 기능
2. 하위 CASE 도구 : 코드를 작성하고 테스트하며 문서화하는 과정 지원
   - 시스템 명세서, 전체 소스코드 생성 기능

  HIPO(Hierarchy Input Process Output)

- 하향식 소프트웨어 개발을 위한 문서화 도구
- 기능과 자료의 의존 관계를 동시에 표현
- 보기 쉽고 이해하기 쉽다

*HIPO 차트 종류 : 가시적 도표, 총체적 도표, 세부적 도표

### 소프트웨어 아키텍처

- 소프트웨어의 구성요소와, 구성요소의 특성, 구성요소 간 관계를 표현하는 구조

소프트웨어 4+1 뷰 : 요구사항을 4 개의 관점에서 바라보는 방법

1. 유스케이스 뷰(Usecase View) : 유스케이스 도출하고 다른 뷰를 검증 하는 뷰
2. 배포 뷰(Deployment View) : 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 보여주는 뷰
3. 프로세스 뷰(Process View) : 비기능적인 속성으로 자원 사용 등을 표현한 뷰
4. 논리 뷰(Logical View) : 기능적인 요구사항이 어떻게 제공되는지 표현한 뷰
5. 구현 뷰(Implementation View) : 소프트웨어 모듈의 구성을 보여주는 뷰

아키텍쳐 비용 평가 모델

- SAAM : 변경 용이성과 기능성에 집중. 경험이 없는 조직에서도 쉽게 사용 가능
- ATAM : SAAM을 계승, 아키텍쳐 품질 속성을 만족하는지도 평가
- CBAM : ATAM 바탕에, 경제적 평가 보장
- ADR : 아키텍쳐 구성요소간 응집도 평가
- ARID : ATAM+ADR. 전체가 아닌 특정 부분에 대한 비용 평가

### 소프트웨어 아키택처 패턴

1. 레이어 패턴(Layers Pattern) : 계층 모델 ex. OSI 7 계층
2. 클라이언트-서버 패턴(Client-Server Pattern) : 하나의 서버와 다수의 클라이언트로 구성
3. 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern) : 3 개의 서브 시스템(모델, 뷰, 제어)으로 구성
4. 파이프 필터 패턴(Pipe-Filter Pattern)
   - 데이터는 파이프를 통해 단방향으로 흐른다
   - 서브시스템이 입력 데이터를 받아 처리하고, 결과를 다른 시스템에 보내는 작업을 반복
   - 데이터 스트림을 생성하고 처리하는 시스템
   - ex) UNIX의 쉘(Shell)
5. 마스터-슬레이브 패턴(Master-Slave Pattern)
   - 마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임지고 슬레이브 프로세스들을 제어 할 수 있다.
   - ex. 장애 허용 시스템, 병렬 컴퓨팅 시스템 (실시간)
6. 브로커 패턴(Broker Pattern)
   - 사용자가 요청하면, 브로커가 적합한 컴포넌트를 연결
   - ex. 분산 시스템
   - 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴으로 컴포넌트 간의 통신을 조정하는 역할을 수행
7. 피어-투-피어 구조(Peer-To-Peer Pattern)
   - 피어를 하나의 컴포넌트로 간주
   - 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
   - ex. 멀티스레딩(Multi Threading) 방식 사용
8. 이벤트-버스 구조(Event-Bus Pattern)
   - 소스가 특정 채널에 이벤트 메시지를 발행하면, 채널을 구독한 리스너들이 메시지를 받아 이벤트 처리
   - 소스 : 이벤트 생성, 리스터 : 이벤트 수행, 채널 : 이벤트 통로, 버스 : 채널 관리
9. 블랙보드 구조(Blackboard Pattern)
   - 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴
   - ex. 음성인식, 차량 식별, 신호 해석
10. 인터프리터 구조(Interpreter Pattern)
    - 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계시 사용

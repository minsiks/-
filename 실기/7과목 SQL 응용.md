# 7과목 SQL 응용

## SQL 문법 ★★★

### 데이터 정의어 (DDL, Data Define Language) 

: 논리적, 물리적인 DB를 정의하거나 수정

- CREATE : DOMAIN, SCHEMA, TABLE, VIEW, INDEX 정의
  - CREATE TABLE 테이블명 ( 컬럼명 데이터타입 [제약조건]; )
  - CREATE VIEW 뷰명 AS ...
  - CREATE INDEX 인덱스명 ON 테이블명(컬럼명)

> 출제) student 테이블의 name 속성에 idx_name를 인덱스 명으로 하는 인덱스를 생성하시오
>
> CREATE INDEX idx_name ON student(name);

- ALTER : TABLE에 대한 정의 변경 (ex. 테이블의 필드가 누락되어 추가할 경우)
  - ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건]
  - ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건]
  - ALTER TABLE 테이블명 DROP 컬럼명
  - ALTER INDEX 인덱스명 ON 테이블명(컬럼명)
- DROP - DOMAIN, SCHEMA, TABLE, VIEW, INDEX 삭제
  - DROP TABLE 테이블명 [CASCADE | RESTRICT]
  - TRUNCATE 테이블명
  - DROP VIEW 뷰이름
  - DROP INDEX 인덱스명
- 참조 무결성을 유지하기 위한 옵션
  - CASCADE : 해당 튜플을 참조하는 튜플도 함께 삭제
  - RESTRICT : 제거할 요소를 다른 테이블이 참조 중이면 제거 취소 (참조 무경성 위배시 연산 거절)
  - SET NULL : 해당 튜플을 참조하는 튜플의 외래키에 NULL 값 삽입 (단, NOT NULL 제약조건 시 연산 거절)

### 데이터 조작어 (DML, Data Manipulation Language)

: 저장된 데이터를 실질적으로 처리

- SELECT : 테이블에서 조건에 맞는 행 검색
  - SELECT 컬럼 FROM 테이블명 (WHERE 조건)
  - HAVING 절은 GROUP BY 와 함께 사용
  - 집계합수의 종류(SELECT 절에 사용) : COUNT, SUM, AVG, MAX, MIN, STDDEV ... 
  - 윈도함수의 종류(SELECT 절에 사용) : RANK, DENSE_RANK, ROW_NUMBER...
  - 그룹함수의 종류(GROUP BY 절에 사용) : ROLLUP, CUBE, GROUPING SETS
  - UNION : 합집합. 중복제거하고 모두 포함
  - UNION ALL : 완전 합집합. 중복까지 포함
  - INTERSECT : 교집합. 겹치는 데이터만 추출
  - MINUS : 차집합. 첫번째 쿼리에만 있고, 두번째 커리에만 없는 결과만 추출
- INSERT : 테이블에 새로운 행 삽입
  - INSERT INTO 테이블명 VALUES ('데이터','데이터','데이터');
- UPDATE : 테이블에서 조건에 맞는 행의 내용 변경
  - UPDATE 테이블명 SET 컬럼명=데이터 [WHERE 조건];
- DELETE : 테이블에서 조건에 맞는 행 삭제
  - DELETE FROM 테이블명 [WHERE 조건]

> 예제문제
>
> SELECT 학과, COUNT(학생) AS '학과별튜플수' FROM 학생
> GROUP BY 학과;
>
> SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적
> GROUP BY 과목이름
> HAVING AVG(점수) >=90;
>
> SELECT ... FROM 학생정보 a JOIN 학과정보 b  ON 학과 = b.학과

### 데이터 제어어 (DCL, Data Control Language)

: 데이터 보안, 무결성 유지, 병행수행 제어

- GRANT : 사용자에게 사용 권한 부여
  - GRANT 권한 ON 테이블 TO 사용자 [WITH GRANT OPTION]

> ex_ GRANT UPDATE ON 고객(테이블) TO 홍길동 WITH GRANT OPTION;
>
> ex_ GRANT SELECT ON B TO A WITH GRANT OPTION; // A에게 B 테이블 SELECT 문 이용할 수 있는 권한 부여

*WITH GRANT OPTION : 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한

- REVOKE : 사용자의 사용 권한 취소

> ex_ REVOKE GRANT OPTION FOR UPDATE ON 고객 FROM 홍길동 CASCADE

*GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소

- COMMIT : 트랜잭션 확정. 트랜잭션 처리가 정상 종료되어 변경된 데이터를 테이블에 영구적으로 반영
- ROLLBACK : 트랜잭션의 실패로 작업을 취소하고, 이전 상태로 되돌리는 데이터 제어어
- SAVEPOINT(CHECKPOINT) : 롤백할 시점 지정 ( 현 시점에서  POINT 까지 트랜잭션 일부만 롤백 )
- 관계형 DB
  - 튜플(Tuple), 행(Row), 레코드(Record) : 튜플 수 = 행 수 = 카디널리티(Cardinality) = 기수 = 대응수
  - 속성(Attribute), 열(Column), 데이터필드(Field) : 속성수 =열 수 = 디그리(Degree) = 차수 = 애트리뷰트수
  - 도메인(Domain) : 하나의 애트리뷰트가 가질 수 있는 원자들의 집합 ex) 성별 속성(Attribute)의 도메인
- 무결성(Integrity)
  1. 개체 무결성 (Entity Intergrity) : 릴레이션에서 기본 키는 널값이나 중복 값을 가질 수 없다.
  2. 도메인 무결성 (Domain Integrity) : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다.
  3. 참조 무결성 (Referential Intergrity) : 외래키는 항상 참조되는 테이블의 기본키여야 한다.
     - 릴레이션의 외래키를 변경하려면 이를 참조하고 있는 다른 릴레이션의 기본키도 변경해야 한다.
  4. 사용자 정의 무결성 (User-Defined Intergrity) : 속성 값들이 사용자가 정의한 제약 조건에 만족해야 한다.

## 트랜잭션(Transaction) ★★

- DB 에서 하나의 논리적 기능을 수행하기 위한 작업 단위

### 트랜잭션의 특성

1. 원자성(Atomicity) : 트랜잭션 연산은 모두 실행되거나, 모두 실행되지 않아야 한다. (All or Nothing)
2. 일관성(Consistency) : 트랜잭션이 성공적으로 실행되면, 트랜잭션 수행 전후 DB 상태가 같아야 한다.
3. 독립성(Isolation) : 트랜잭션 실행 도중에 다른 트랜잭션의 연산이 끼어들 수 없다.
4. 영속성(Durability) : 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영되어야 한다.

## 회복(Recovery) ★

- 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 전의 정상적인 상태로 복구

### 회복 기법 종류

1. 로그 기반 회복 기법
   - 즉시갱신 회복 기법(Immediate Update)
     - 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영. 장애 발생시 로그를 참고하여 되돌림
     - Rollback 시 Redo, Undo가 모두 실행, 트랜잭션 수행중 갱신 결과를 바로 DB에 반영
   - 자연갱신 회복 기법(Deferred Update)
     - 트랜잭션이 완료 전에는 로그에만 기록. 장애 발생시 로그 폐기
   - 체크포인트 회복 기법 (Checkpoint Recovery)
     - 장애 발생시, 체키포인트 이전으로 복원 (검사점 이후에 처리된 트랜잭션에 대해서만)
   - 그림자 페이징 회복 기법
     - 트랜잭션 수행시 복제본 생성, 장애 발생시 이를 이용해 복구
   - undo, redo
     - undo : 작업을 취소하여 트랜잭션을 이전 상태로 되돌리는 것
     - redo : 오류가 발생하기 전까지의 사항을 로그(log)로 기록해 놓고, 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 현상
   - 장애의 유형
     - 트랜잭션 장애 : 트랜잭션 내부의 비정상적인 상황으로 인해 프로그램이 실행이 중지
     - 시스템 장애 : 하드웨어의 오동작, 소프트웨어 손상, 교착상태 등으로 모든 트랜잭션의 연속적인 수행에 장애
     - 미디어 장애 : 저장장치인 디스크 블록 손상 등으로 DB가 물리적으로 손상된 상태

## 이상(Anomaly) ★★

- 데이터 중복으로 인해 릴레이션 조작 시 발생하는 비합리적 현상

### 이상의 종류

- 삽입 이상(Insertion) : 릴레이션에 데이터를 삽입할 때 의도와 상관없이 원하지 않은 값들도 함께 삽입
- 삭제 이상(Deletion) : 릴레이션에서 한 튜플을 삭제할 때 의도와 상관없는 값들도 함께 연쇄 삭제
- 갱신 이상(Update) : 릴레이션에서 튜플에 있는 속성 값을 갱신시 일부 튜플의 정보만 갱신

### 병행 제어(로킹)

- 다수 사용자 환경에서 일관성을 유지를 위해 제어하는 기법

- 로킹 단위
  - 로킹 : 트랜잭션의 순차적 진행을 보장하는 기법
  - 로킹 단위 : 한번에 로킹할 수 있는 객체 크기
  - 로킹단위가 커지면 로크의 수 ↓ 로킹 오버헤드 ↓ 병행성 수준 ↓ 데이터베이스 공유도 ↓ 병행 제어 기법 용이
  - 로킹단위가 작으면 로크의 수 ↑ 로킹 오버헤드 ↑ 병행성 수전 ↑ 데이터베이스 공유도 ↑ 병행 제어 기법 복잡

### 데이터베이스 병행제어 기법의 종류

1. 로킹 기법 : 접근한 데이터에 대한 연산을 모두 마칠때까지 상호배제하는 기법
2. 낙관적 검증 (최적 병행 수행기법) : 일단 검증 없이 진행 후, 트랜잭션 종료시 검증을 수행해 반영
3. 타임스탬프 기법(Timestamp) : 트랜잭션간 타임스탬프(처리 순서)를 미리 정해 그 시간에 따라 작업을 수행
4. 다중버전 기법 : 트랜잭션의 타임스탬프 vs 접근하는 데이터의 타임스탬프 비교. 적절한 버전 선택

## 데이터베이스 설계 ★

- 데이터베이스 설계 시 고려사항 : 무결성, 일관석, 회복, 보안, 효율성, 데이터베이스 확장
- DBMS분석시 고려사항 : 무결성(가용성), 효율성(성능), 일관성(상호 호환성), 기술지원, 구축 비용
- 데이터베이스 설계 순서 : 요구사항 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 구현

### 개념적 설계 (정보 모델링)

- 개념 스키마 모델링, 트랜잭션 모델링
- 독립적인 개념 스키마 설계
- E-R 다이어그램 모델
- 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산축물에는 E-R 다이어그램이 있다.

### 논리적 설계 (데이터 모델링)

- 목표 DBMS에 맞는 스키마 설계
- 트랜잭션 인터페이스 설계
- 관계형 데이터베이스에서 테이블 설계하는 단계
- 스키마의 평가 및 정제
- 논리적 데이터베이스 구조로 매핑
- 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행

### 물리적 설계 (데이터 구조화)

- 물리적 설계의 목적은 효율적인 방법으로 데이터를 저장하는 것이다.
- 트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려해야 한다.
- 저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 설계
- 레코드의 집중의 분석 및 설계
- 접근 경로 설계
- 저장 레코드의 양식 설계
- 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있다.

### 데이터베이스 (Database) 특징

- 공용 데이터 (Shared Data) : 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료
- 통합된 데이터(Intergrated Data) : 자료의 중복을 최대로 배제한 데이터의 모임
- 운영 데이터(Operational Data) : 고유한 업무를 수행하는 데 없어서는 안 될 자료
- 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료

### 스키마

- 데이터베이스의 전체적인 구조와 제약조건에 대한 명세

1. 외부 스키마(External Schema) = 서브 스키마
   - 사용자의 관점에서 보여주는 데이터베이스 구조. 전체 데이터베이스의 일부이므로 서브 스키마라고도 함
   - 사용자 뷰, 사용자(개발자) 관점에서 구조
2. 내부 스키마(Internal schema)
   - 물리적 저장 장치의 입장에서 본 데이터베이스 구조
3. 개념 스키마(Conceptual Schema)
   - 데이터베이스 전체를 정의
   - 제약조건, 권한, 보안 등 전체적인 논리 구조

## 키(Key)

### 후보키(Candidate Key)

- 릴레이션에 있는 모든 튜플에 대해 유일성과 최소성을 만족시켜야 한다.
- 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재

### 기본키 (Primary Key)

- 후보키 중에서 특별히 선정된 메인 키. 중복된 값과 NULL값을 가질 수 없음
- 후보키의 성질인 유일성과 최소성을 가지며, 튜플을 식별하기 위해 반드시 필요한 키

### 대체키(Alternate Key)

- 기본키를 제외한 나머지 후보키

### 슈퍼키(Super Key)

- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
- 릴레이션을 있는 모든 튜플에 대해 유일성은 만족시키지만 최소성은 만족시키지 못한다.

### 외래키(Foreign Key)

- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
- 참조되는 릴레이션의 기본키와 대응돼 릴레이션 간의 참조 관계 표현

## 파니셔닝 테이블

### 파티션(Partition) 유형

1. 범위 분할, 레인지 파티셔닝(Range Partitioning) : 연속적인 숫자나 날짜 기준으로 분할 ex) 일/월/분기별
2. 해시 분할, 해시 파티셔닝(Hash Partitioning) : 해시 함수에 따라 데이터 분할
3. 조합 분할, 컴포지트 파티셔닝(Composite Partioning) : 범위분할 후 해시분활 ex) 범위분할 + 해시분할
4. 리스트 파티셔닝(List Partitioning) : 미리 정해진 그룹핑 기준에 따라 분할 (값 목록을 기준으로 분할)

## 분산 데이터베이스의 투명성

### 분산데이터베이스의 목표

- 위치 투명성(Location Transparency)
  - 하드웨어와 소프트웨어의 물맂거 위치를 사용자가 알 필요가 없다.

- 중복 투명성(Replication Transparency, 복제 투명성)
  - 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용, 시스템은 자동으로 여러 자료에 대한 작업을 수행
- 병행 투명성(Concurrency Transparency)
  - 다중 사용자들이 자원들을 자동으로 공유할 수 있다.
  - 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
- 분할 투명성(Division Transprarency)
  - 하나의 논리가 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있을을 인식할 필요가 없음
- 장애 투명성 (Failure Transparency)
  - 데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장
- 이주 투명성
  - 자원들이 한 곳에서 다른 곳으로 이동하면 자원들의 이름도 자동으로 바꾸어지지 않는다..
- 복제 투명성
  - 사용자에게 통지 할 필요 없이 싯템 안에 파일들과 자원들의 부가적인 복사를 자유롭게 할 수 있다.

## 절차형 SQL

- SQL 안에서도 절차지향적인 프로그래밍이 가능하도록 하는 트랜잭션 언어

### 절자형 SQL 종류

- 프로시저(Procedure) : 사전 정의된 SQL을 호출하면 특정 작업을 실행 (값 반환 X)
- 트리거(Trigger) : 삽입, 갱신, 삭제 등 이벤트 발생시 자동으로 관련 작업이 수행
- 사용자 정의 함수 :SQL 수행 후 처리결과를 단일값으로 반환

### PL/SQL

: 표준 SQL을 기반으로 오라클에서 개발한 데이터 조작 언어

## 쿼리 성능 개선

### 쿼리 성능 최적화

- 옵티마이저(Optimizer) : SQL이 가장 효율적으로 수행되도록 최적의 처리경로를 찾는 DBMS 의 모듈
- 실행 계획 (Execution plan) : 옵티마이저가 생성한 처리경로
- 힌트(Hint) : 명시적인 힌트를 통해 옵티마이저의 실행 계획을 변경 가능

### 옵티마이저 유형

1. RBO(규칙 기반, Rule Based Optimizer) : 사전에 등록된 규칙에 따라 실행 계획을 선택 (규칙=우선순위 기반)
2. CBO(비용 기반, Cost Based Optimizer) : 모든 접근 경로를 고려해 실행 계획을 선택 (비용=수행시간 기반)

### 인덱스(index)

- 검색 성능 최적화를 위해 키 값과 포인터의 쌍으로 구성되는 데이터 구조
- 테이블과 클러스터에 연관되어 독립적인 저장 공간 보유

### 인덱스 종류

- 순서 인덱스(Ordered Index) : 데이터가 정렬된 순서대로 생성되는 인덱스
- 해시 인덱스(Hash Index) : 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
- 비트맵 인덱스(Bitmap Index) : bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 인덱스
- 함수기반 인덱스(Functional Index) : 수식이나 함수를 적용하여 만든 인덱스
- 단일 인덱스(Single Index) : 하나의 컬럼으로만 구성한 인덱스
- 결합 인덱스(Concatenated Index) : 두 개 이상의 컬럼으로 구성한 인덱스
- 클러스터드 인덱스(Clustered Index) : 인덱스 키 순서에 따라 데이터가 정렬되어 저장되는 방식 (검색 빠름)
- 넌클러스터드 인덱스(Non-Clustered Index) : 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식 (데이터 삽입, 삭제시 데이터 재정렬 해야함)

### 인덱스 스캔 방식

- 범위 스캔(Index Range Scan) : :arrow_down::arrow_right: 루트풀록에서 리프블록까지 수직 탐색 후 리프블록을 수평 탐색
- 전체 스캔(Index Full Scan) : :arrow_right::arrow_right: 리프블록을 처음부터 끝까지 수평 탐색
- 단일 스캔(Index Unique Scan) :arrow_down::arrow_down: 수직 탐색으로만 스캔
- 생략 스캔(Index Skip Scan) : 선두 컬럼이 조건절에 빠졌어도 인덱스를 활용하는 스캔

### 뷰(View)

- 사용자에게 허용된 정보만 보여주기 위해 하나 이상의 테이블로부터 유도된 논리적인 가상 테이블

### 클러스터(cluster)

- 데이터의 접근 효율을 높이기 위해 물리적 저장 방법
- 동일한 성격의 데이터를 같은 데이터 블록에 저장하는 방법
- 인덱스의 단점을 해결한 기법 -> 분포도가 넓을수록(=좋지 않을수록) 적합
- 대량의 범위를 자주 액세스(조회)하는 경우 적용

## DB 암호화 기법

- API 방식 : 애플리케이션 서버에 암호 모듈 적용
- Plug-in 방식 : DB 서버에 암호 모듈 적용
- TDE 방식 : DB 서버의 DBMS 커널이 자체적으로 암복호화 기능 수행
- Hybrid 방식 : API 방식 + Plug-In (부하 분산)

## 빅데이터

- 기존의 관리 방법이나 분석 체계로는 처리하기 어려운 방대한 양의 정형/비정형 데이터 집합
- 데이터의 양(Volumn), 데이터의 다양성(Variety), 데이터의 속도(Velocity)

- 정형 데이터 수집 : ex. 스쿱(Squoop), 하이호(Hiho), ETL, FTP
- 비정형 데이터 수집 : ex. 척와(Chuckwa), 플럼(Flume), 스크라이브(Scribe)
- 분산 데이터 저장 : HDFS (하둡 분산 파일 시스템)
- 분산 데이터 처리 : 맵리듀스
- 분산 데이터베이스 : ex. Hbase

### Map Reduce(맵리듀스)

- 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델
- 구글에서 대용량 데이터를 분산 병렬 컴퓨팅에서 처리하기 위한 목적(하둡)
- 임의의 순서로 정렬된 데이터를 분산 처리하고 이를 다시 합치는 과정을 거친다.

### Hadoop (하둡)

- 오픈 소스 기반으로 한 분산 컴퓨팅 플랫폼
- 일반 PC 급 컴퓨터들로 가상화된 대형 스토리지를 형성, 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크로 구글, 야후 등에 적용한 기술

### 빅데이터 분석 및 처리 기술

1. 빅데이터 분석
   - 데이터 가공 : ex. 피그(Pig), 하이브(Hive)
   - 데이터 마이닝 : ex. 머하웃(Mahout)

2. 빅데이터 실시간 처리
   - 실시간 SQL 처리 : ex. 임팔라(Impala)
   - 요청 작업의 워크플로우 관리 : ex. 우지(Oozie)

3. 분산 코디네이션
   - 분산 처리 기술 ex. 주키퍼(Zookeeper)
4. 분산 및 시각화
   - 시각화 기술 : ex) R

## 데이터 마이닝

### 데이터 마이닝 (Data Mining)

- 대량의 데이터 안에서 체계적이고 일정한 규칙이나 패턴을 찾아내는 기술

### 텍스트 마이닝

- 대량의 텍스트 속에서 의미있는 정보를 찾아내는 기법 (자연어, 문서 처리기술 적용)

### 웹 마이닝

- 웹으로부터 얻는 방대한 정보 속에서 의미있는 정보를 찾아내는 기법 (데이터 마이닝 기술 응용)

### 데이터 마이닝 기법

- 데이터 군집화(Clustering) : 유사한 특성을 지닌 그룹으로 분류하되 정보가 없는 상태에서 분류
- 연관 규칙(Association) : 데이터 항목 간 종속 관계를 찾아냄. ex. 넥타이 구매자는 셔츠도 같이 구매
- 연속 규칙(Sequence) : 연관 규칙 + 시간 관련 정보가 포함된 기법
- 분류 규칙(Classification) : 과거 데이터로부터 분류 모델을 만들어 이를 토대로 새로운 결과 값을 예측

### Tajo(타조)

- 하둡(Hadoop) 기반 데이터웨어하우스 시스템

### 데이터 웨어하우스(Data Warehouse)

- 다량의 데이터를 효과적으로 분석하여 정보화하고 효율적으로 사용할 수 있게 된 DB

## NoSQL

- 전통적인 RDBMS가 아닌 DVMS 를 지칭하는 용어 (Not Only SQL)
- 테이블 스키마 불필요, 조인 연산 불가, 수평적으로 확장 가능한 DBMS

### NoSQL의 유형

- Key-Value Store : Unique 한 키에 하나의 Value를 가지고 있는 형태의 DB (ex. Redis, DynamoDB)
- Column Family Data Store : 키 안에 (Column, Value) 조합으로 된 필드를 갖는 DB (ex. HBase, Cassandra)
- Document Stre : Value의 데이터 타입이 문서(Document) 타입을 사용하는 DB (ex. MongoDB, Couchbase)
- Graph Store : 시멘틱 웹, 온톨리지 부냥에서 활용되는 그래프로 데이터 표현하는 DB(ex. Neo4j, AllegroGraph)

### NoSQL의 특징

- Basically Available : 언제든지 접근 가능해야 함
- Soft-State : 노드의 상태는 외부 정보로 결정
- Eventually Consistency : 일정 시간이 지나면 데이터 일관성이 유지

# 3과목 데이터베이스 구축 1~29

## 1. 데이터베이스 설계

- 데이터베이스 설계 순서
  - 요구 조건 분석
  - 개념적 설계 : 독립적인 개념 스키마 모델링, 트랜잭션 모델링
  - 논리적 설계 : 종속적인 논리 스키마 설계, 인터페이스 설계, 논리적 매핑, 평가 및 정제
  - 물리적 설계 : 종속적인 물리적 구조의 데이터, 저장 레코드, 접근 경로
  - 구현 : 생성

## 2. 데이터 모델

- 데이터 모델의 구성 요소
  - 개체 : 사람이 생각하는 개념이나 정보 단위
  - 속성 : 데이터의 가장 논리적 단위, 데이터 항목, 데이터 필드
  - 관계 : 개체 간의 관계
- 개념적 데이터 모델 
  - 추상적 개념으로 표현
- 논리적 모델
  - 컴퓨터 세계의 환경에 맞도록 변환
- 데이터 모델에 표시할 요소
  - 구조 : 데이터 구조
  - 연산 : 처리하는 작업, 조작
  - 제약 조건 : 논리적인 제약 조건

## 3. 개체

- 개체의 정의 및 특징
  - 유형, 무형의 정보
  - 사람이 생각하는 개념이나 정보 단위
  - 그 자체로서도 구별 가능
  - 유일한 식별자에 의해 식별 가능
- 개체 선정 방법
  - 당담자와 인터뷰
  - 장부와 전표
  - 자료 흐름도(DFD: Data Flow Diagram), 자료 저장소를 이용
  - BPR(Business Process Reengineering, 업무 프로세스 재설계)
- 개체명 지정 방법
  - 업무에서 사용하는 용어
  - 약어 사용은 되도록 제한
  - 단수 명사
  - 개체명은 유일

## 4. 속성

- 속성의 정의 및 특징
  - 가장 작은 논리적 단위
  - 데이터 항목 또는 데이터 필드
  - 구성하는 항목, 특성을 기술
  - 속성의 수를 디그리 또는 차수
  - 튜플의 수는 카디널리티
- 속성의 특성에 따른 분류
  - 기본 속성 : 업무 분석을 통해 정의 (자동차명, 제조일)
  - 설꼐 속성 : 원래 업무상 존재하지 않고 설계 과정에서 도출 (자동차 코드)
  - 파생 속성 : 다른 속성으로부터 영향 (계산 값)
- 개체 구성 방식에 따른 분류
  - 기본 키 속성
  - 외래 키 속성
  - 일반 속성

- 속성명 지정 원칙
  - 업무에서 사용하는 용어
  - 약어의 사용은 제한
  - 유일하게 식별 가능하도록 지정

## 5. 관계

- 관계의 형태
  - 일대일
  - 일대다
  - 다대다
- 관계의 종류
  - 종속, 중복, 재귀, 배타
- 식별자
  - 인스턴스를 유일하게 구분
  - 한 개 이상의 식별자를 반드시
- 대표성 여부
  - 주 식별자 : 하나의 개체에 한 개
  - 보조 식별자 : 하나의 개체에 한 개 이상
- 스스로 생성 여부
  - 내부 식별자 : 개체 내
  - 외부 식별자 : 외부 개체의 식별자를 가져와, 연결자 역할
- 단일 속성 여부
  - 단일 식별자 : 주 식별자가 한 가지 속성
  - 복합 식별자 : 주 식별자가 두 개 이상의 속성
- 대체 여부
  - 원조 식별자 : 가공되지 않은 원래의 식별자
  - 대리 식별자 : 하나의 속성으로 묶어 사용

## 7. E-R(개체-관계) 모델

- 개요
  - 개념적 데이터 모델
  - 1:1, 1:N, N:M

## 8. 관계형 데이터 모델

- 개요
  - 표를 이용
  - 기본 키, 외래 키 관계 표현
  - SQL, 1:1, 1:N, N:M 관계

## 9. 관계형 데이터베이스의 구조

- 관계형 데이터베이스의 Relation 구조
  - 튜플, 행, 레코드
    - 튜플의 수 = 카디널리티
  - 속성, 열, 필드
    - 가장 작은 논리적 단위
    - 데이터 항목 또는 데이터 필드
    - 개체의 특성을 기술
    - 속성의 수 = 디그리 또는 차수
  - 도메인
    - 속성이 가질 수 있는 같은 타입 원자값들의 집합
    - ex. 성별 속성의 도메인은 '남','여'로 그 외의 값은 입력 될 수 없음(일반적)
- 릴레이션의 특징
  - 튜플(행)들은 모두 상이, 서로 다른 값
  - 튜플(행) 사이에는 순서가 없음
  - 애트리뷰트(열) 간의 순서는 중요하지 않음
  - 애트리뷰트는 식별을 위해 릴레이션 내에서 유일한 이름
  - 애트리뷰트는 원자 값으로 저장
- 정리 : 튜플은 서로 상이한 값을 갖고, 순서가 없음, 애트리뷰트는 원자 값을 가지고, 순서가 중요하지 않으며, 유일한 이름을 가짐

## 10. 키

튜플들을 서로 구분할 수 있는 기준이 되는 속성

- 후보키(Candidate Key)
  - 속성들의 부분집합, 반드시 하나 이상의 후보키
  - 유일성과 최소성을 만족
    - 유일성 : 유일하게 식별
    - 최소성 : 꼭 필요한 속성으로만 구성
- 기본키
  - 중복된 값과 널값을 가질 수 없음
  - 유일성과 최소성을 가짐
- 대체키(Alternate Key)
  - 기본키를 제외한 나머지 후보키
- 슈퍼키
  - 최소성은 만족시키지 못함
- 외래키
  - 참조
  - 릴레이션 간의 참조 관계

## 11. 무결성

일치하는 정확성

- 개체 무결성(Entity Integrity, 실체 무결성)
  - 어떤 속성도 널값이나 중복 값을 가질 수 없음
  - 기본키의 속성 값이 널값이 아닌 원자 값을 갖는 성질
- 도메인 무결성(영역 무결성)
  - 도메인에 지정된 값 만
- 참조 무결성
  - 참조 릴레이션의 기본키 값과 동일
  - 참조할 수 없는 외래키 값을 가질 수 없다
- 사용자 정의 무결성
  - 사용자가 정의한 제약 조건에 만족
- 데이터 무결성 강화
  - 애플리케이션 : 프로그램 내에 추가
  - 데이터베이스 트리고 : 트리거 이벤트에 절차형 SQL 추가
  - 제약 조건 : 제약 조건을 설정

## 12. 관계대수 및 관계해석

- 관계대수
  - 어떻게 유도하는가를 기술하는 절차적인 언어
  - 순수관계 연산자

| **연산자**             | **기호**        | **의미**                                                     |
| ---------------------- | --------------- | ------------------------------------------------------------ |
| **Sel**ect  (선택)     | σ               | 조건(Predicate)을 만족하는  튜플들의 부분 집합  (수평 연산) **★** |
| **P**roject  (추출)    | π               | 속성들의 부분  집합, 중복은 제거됨  (수직 연산) **★**        |
| **Jo**in  (조인)       | ▷◁  ex)  R ▷◁ S | 두 개의 릴레이션이  공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산 **★**  두 개의 릴레이션의  연관된 튜플들을 결합 |
| **D**ivision  (나누기) | ÷  ex) R ÷ S    | R릴레이션에서 S릴레이션의 속성 도메인 값과 일치하는  R릴레이션의 튜플들을 찾아내는 연산 **★** |

- 일반집합 연산자

| **연산자**                      | **기호**           | **의미**                                                     |
| ------------------------------- | ------------------ | ------------------------------------------------------------ |
| Union  (**합**집합)             | **∪**  ex) R**∪**S | 두 개의 릴레이션의  합이 추출되고, 중복은 제거됨             |
| Intersection  (**교**집합)      | **∩**  ex) R**∩**S | R릴레이션과 S릴레이션의 중복되는 값들만 추출                 |
| Difference  (**차**집합)        | **—**  ex) R - S   | R릴레이션에서 S릴레이션에 중복되지 않는 값들만  추출         |
| **Car**tesian Product  (교차곱) | **Х**  ex)  R x S  | 두 릴레이션의 가능한  모든 튜플들의 집합,  차수(Degree)는 더하고, 카디널리티(Cardinality)는 곱해서 값을 구함 **★** |

- 관계해석
  - 수학의 predicate Calculus(술어 해석)에 기반
  - 무엇, 비절차적 특성
  - 튜플 관계해석, 도메인 관계해석
  - 처리하는 기능과 능력면에서 동등
  - 관계대수로 표현한 식은 관계해석으로 표현

| **구분**                               | **구성요소**                        | **기호**                                                     | **설명**                                                    |
| -------------------------------------- | ----------------------------------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
| 연산자                                 | OR  연산                            | V                                                            | 원자식 간 “또는”이라는 관계로 연결                          |
| AND  연산                              | ∧                                   | 원자식 간 “그리고”라는 관계로 연결                           |                                                             |
| NOT  연산                              | ㄱ                                  | 원자식에 대해 부정                                           |                                                             |
| 정량자                                 | 전칭 정량자  (Universal  Quantifier | ∀                                                            | 모든 가능한 튜플 “For All”  # All의 ‘A’를 뒤집은 형태 **★** |
| 존재 정량자  (Existential  Quantifier) | ∃                                   | 어떤 튜플 하나라도 존재 “There  Exists”  # Exists의 ‘E’를 뒤집은 형태 **★** |                                                             |

- 관계대수와 관계해석 비교

| **구분** | **관계대수**                     | **관계해석**                                                 |
| -------- | -------------------------------- | ------------------------------------------------------------ |
| 특징     | 절차적 언어(순서 명시)           | 비절차적 언어(계산 수식의 유연적 사용),  프레디킷 해석(Predicate Calculus) 기반 |
| 목적     | 어떻게 유도하는가?(How)          | 무엇을 얻을 것인가?(What)                                    |
| 종류     | 순수관계 연산자, 일반집합 연산자 | 튜플 관계 해석, 도메인 관계 해석                             |

## 13. 정규화(Nomalization), 반정규화(Denormalization)

분해, 논리적 설계 단계

- 정규화의 목적
  - 안정성 및 무결성
  - 데이터베이스 내에서 표현 가능
  - 효과적인 검색 알고리즘 생성
  - 중복을 배제해 이상의 발생 방지
  - 릴레이션을 재구성할 필요성을 줄임
- 이상(Anomaly)의 개념 및 종류
  - 불필요하게 중복
    - 삽입 이상(Insertion Anomaly) : 의도와 상관없이 원하지 않은 값들도 함께 삽입
    - 삭제 이상 : 의도와는 상관없는 값들도 함께 삭제
    - 갱신 이상 : 일부 튜플의 정보만 갱신
- 정규화의 원칙
  - 무손실, 분리, 중복성 감소
- 정규화 과정
  - 제 1 정규형 : 모든 도메인이 원자 값
  - 제 2 정규형 : 완전 함수적 정속을 만족, 부분적 함수 종속을 제거
  - 제 3 정규형 : 이행적 함수 종 속 관계를 만족 X
  - BCNF : 모든 결정자가 후보키
  - 제 4 정규형 : 다치 종속이 성립
  - 제 5 정규형 : 모든 조인 종속
- 반정규화 개념
  - 시스템의 성능 향상, 정규화된 데이터 모델을 통합, 중복, 준리하는 과정
- 반정규화 방법
  - 테이블 통합 : 1:1 관계 , 1:N 관계, 슈퍼타입/서브타입

## 14. 시스템 카탈로그

- 시스템 카탈로그의 의미
  - 정보를 유지 관리하는 시스템 테이블
  - 데이터 사전
  - 메타 데이터
- 카탈로그의 특징
  - 내용을 검색
  - 카탈로그를 갱신할 수 없음
  - DBMS가 스스로 생성하고 유지함
  - 시스템이 자동으로 갱신
- 데이터 디렉터리
  - 실제로 접근하는 데 필요한 정보
  - 시스템만 접근

## 15. 데이터베이스 저장 공간 설계

- 테이블
  - 행, 열
- 클러스터드 인덱스 테이블
  - 순서에 따라 데이터가 저장
  - 접근 경로가 단축
- 파티셔닝 테이블
  - 대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블
  - 레인지 파티셔닝 : 지정된 열의 값을 기준
  - 해시 파티 셔닝 : 해시 함수
  - 리스트 파티셔닝 : 미리 정해진 그룹핑
  - 컴포지트 파티셔닝 : 레인지 + 해시
- 외부 테이블
  - 외부 파일
- 임시 테이블
  - 임시로 사용
- 컬럼
- 테이블스페이스
  - 논리적인 영역

## 16. 트랜잭션

- 트랜잭션의 정의
  - 하나의 논리적 기능을 수행하기 위한 작업의 단위
  - 일련의 연산들
    - COMMIT : 정상적으로 종료, 변경 내용을 DB에 반영
    - ROLLBACK : 비정상으로 종료, 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는
    - SAVEPOINT : ROLLBACK 할 위치인 저장점을 지정
- 트랜잭션의 특성
  - 원자성 : 모두에 반영되든지 아니면 전혀 반영되지 않아야 함
  - 일관성 : 일관성 있는
  - 독립성 : 한 개의 트랜잭션만 접근이 가능
  - 영속성 : 영구적으로 반영
- CRUD 매트릭스
  - 프로세스는 하나만 있어도 돌아감

## 17. 인덱스

- 인덱스의 개념 및 선정기준, 고려사항
  - 빠르게 접근 <키 값, 포인터>
    - 인덱스 컬럼 선정
      - 분포도가 10~15% 이내
      - 수정이 빈번하지 않는 컬럼
      - ORDER BY, GROUP BY, UNION 이 빈번한 컬럼
      - 분포도가 좋은 컬럼은 단독 인덱스
      - 인덱스들이 자주 조합, 결합 인덱스
    - 설계시 고려사항
      - 지나치게 많은 인덱스는 오버헤드
      - 넓은 범위 인덱스 처리시, 많은 오버헤드
      - 인덱스만의 추가적인 저장 공간
      - 저장 공간이 분리
- 인덱스 종류
  - 클러스터드 인덱스, 넌클러스터드 인덱스
  - 트리 기반 인덱스
  - 비트맵 인덱스
  - 함수 기반 인덱스
  - 비트맵 조인 인덱스

## 18. 뷰

- 뷰의 개요 및 특징
  - 기본 테이블로부터 유도, 가상 테이블
  - 가상 테이블 -> 저장장치 내에 논리적으로 존재
  - 정의된 뷰로 다른 뷰를 정의
  - 다른 뷰도 자동으로 삭제
  - REPLACE : 재생성
  - FORCE : 존재 여부에 관계 없이 뷰 생성
  - NOFORCE : 존재할 때만 뷰생성
- 뷰의 장, 단점
  - 장점
    - 논리적 데이터 독립성 제공
    - 자동 보안 제공
    - 데이터 관리 용이
  - 단점
    - 독립적인 인덱스를 가질 수 없음
    - ALTER로 변경 할 수 없음 -> DROP하고 새로 CREATE
    - 삽입, 삭제, 갱신, 연산에 제약이 따름

## 19. 클러스터

- 클러스터의 개요 및 특징
  - 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법
  - 분포도가 넓을수록 오히려 유리
  - 분포도가 넓은 테이블, 저장공간의 절약이 가능
  - 대량의 범위
  - 넓은 분포도
- 클러스터의 선정기준 및 고려사항
  - 클러스터 테이블 선정
    - 수정이 빈번하지 않는 테이블
    - ORDER BY, GROUP BY, UNION 이 빈번한 테이블
    - 처리 범위가 넓어, 단일 테이블 클러스터링
    - 조인이 많아, 다중 테이블 클러스터링
  - 설계 시 고려사항
    - 조회 속도를 향상, BUT 입력, 수정, 삭제 시 성능이 저하됨(부하가 증가)

## 20. 분산 데이터베이스 정의

- 분산 데이터베이스 정의
  - 논리적으로는 하나의 시스템, 물리적으로는 분산돼 있는 데이터베이스
- 분산 데이터 베이스의 구성 요소
  - 분산 처리기 : 자체적으로 처리 능력
  - 분산 데이터베이스 : 해당 지역의 특성에 맞게 구성
  - 통신 네트워크 : 논리적으로 하나의 시스템처럼 작동할 수 있도록
- 분산 데이터베이스의 목표
  - 위치 투명성 : 실제 위치를 알 필요 없이
  - 중복 투명성 : 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용
  - 병행 투명성 : 동시에 실현
  - 분할 투명성 : 여러 단편으로 분할
  - 장애 투명성 : 장애가 발생해도 트랜잭션을 정확하게 처리
- 분산 데이터베이스의 장, 단점
  - 장점 : 지역 자지청이 높은, 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음, 신뢰성 및 가용성, 점진적 확장 용이
  - 단점 : 비용 증가. 어려움, 보안 취약

## 21. 데이터베이스 이중화 / 서버 클러스터링

- 데이터베이스 이중화
  - 물리적 손상 발생시 이를 복구하기 위해 동일한 데이터베이스를 복제, 관리
- 데이터베이스 이중화의 분류
  - Eager 기법 : 즉신 전달해 변경 내용이 즉시 적용
  - Lazy 기법 : 변경 사실을 새로운 트랜잭션에 작성
- 데이터베이스 이중화 구성 방법
  - 활동-대기 : 한 DB가 활동 상태로 서비스, 다른 DB는 대기
  - 활동-활동 : 두 개의 DB가 서로 다른 서비스를 제공, 구성 방법 및 설정 복잡
- 서버 클러스터링
  - 두 대 이상의 서버를 하나의 서버처럼 운영
    - 고가용성 클러스터링 : 하나 서버 장애발생, 다른 서버가 대신처리
    - 병렬 처리 클러스터링 : 하나의 작업을 여러개의 서버에 분산처리

## 22. 데이터베이스 보안/ 스토리지

- 데이터베이스 보안의 개요
  - 권한이 없는 사용자 X
- 암호화
  - 암호화 과정
    - 암호화 되지 않은 평분을 정보 보호를 위해 암호문으로 바꾸는 과정
  - 복호화 과정
    - 암호문을 원래의 평문
- 암호화 방식
  - 개인키 암호 방식 : 동일한 키
  - 공개키 암호 방식 : 암호화할 대 사용하는 키(공개키)-사용자, 복호화할 때의 키(비밀키)-관리자
- 접근통제
  - 정보 흐름을 제한
  - 3요소 : 정책, 보안모델, 메커니즘
  - 임의 접근통제(DAC)
    - 사용자의 신원에 따라
  - 강제 접근통제(MAC)
    - 등급을 비교
- 접근통제 정책
  - 신분 기반 정책(DAC)
  - 규칙 기반 정책(MAC)
  - 역할 기반 정책(RBAC)

- 접근통제 메커니즘
  - 접근통제 목록(ACL) : 객체를 기준
  - 능력 리스트 (CL) : 주체를 기준
- 접근통제 보안 모델
  - 기밀성 모델 : 기밀성 보장 , No Read Up(기밀성)
  - 무결성 모델 : 정보 변경을 방지, No Write Up(무결성)
- 스토리지
  - DAS : 전용 케이블로 직접 연결, 설치 및 운영이 쉬움, 비용 저렴
  - NAS : 네트워크를 통해 연결, 확장성 및 유연성 우수
  - SAN : 전용 네트워크를 별도로 구성 , 파이버 채널 스위치, 광케이블

## 23. 논리 데이터 모델의 물리 데이터 모델 변환 및 품질 검토

- 일반적인 변환 절차
  - 단위 개체를 테이블 -> 속성을 컬럼 -> UID를 기본 키 -> 관계를 외래 키-> 컬럼의 유형과 길이 정의 -> 반정규화
- 슈퍼타입/서브타입을 테이블로 변환
  - 슈퍼타입 기준 테이블 변환 :서브타입을 슈퍼타입에 통합
  - 서브타입 기준 테이블 변환 :슈퍼타입 속성들을 각각의 서브타입에 추가, 서브타입들을 개별적인 테이블
  - 개별타입 기준 테이블 변환 : 각각의 개별적인 테이블로 변환
- 물리 데이터 모델 품질 기준
  - 정확성
  - 완전성
  - 준거성
  - 최신성
  - 일관성
  - 활용성

## 24. SQL 응용

- SQL의 분류
  - DDL
  - DML
  - DCL

## 25. SQL 활용

- 절차형 SQL
  - 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
  - 프로그래밍 언어에 비해 효율이 떨어지지만, 연속적인 작업 처리
  - BEGIN ~ END 형식, 기능별 모듈화 가능
- 프로시저
  - 미리 저장해 놓은 SQL 작업 수행, 한 개 이상의 값 혹은 반환을 아예 하지 않음
  - 일일 마감 작업, 일괄 작업 등에 주로 사용
  - DECLARE(필수): 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부
  - BEGIN(필수) : 시작, 실행부
  - CONTROL : 조건문 또는 반복문이 삽입, 순차적으로 처리
  - SQL: DML, DCL
  - EXCEPTION: 예외 발생하면 이를 처리
  - TRANSACTION : 작업들을 DB에 적용할지 말지 결정
  - END(필수) : 프로시저의 종료
- 트리거
  - 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업을 자동 수행
  - 데이터 변경 및 무결성 유지, 로그 메시지 출력
  - DCL(데이터 제어어)을 사용할 수 없음
  - 트리거가 처리하는데에도 영향
  - DECLARE(필수) : 트리거의 명칭, 변수 등 정의하는 선언부
  - EVENT(필수) : 트리거가 실행되는 조건
  - BEGIN(필수) : 트리거의 시작, 실행부
  - CONTROL : 조건문, 반복문, 삽입 순차적 처리
  - SQL : DML문이 삽입
  - EXCEPTION : 예외처리
  - END(필수) : 종료

- 사용자 정의 함수
  - 프로시저와 유사
  - 예약어 RETURN을 사용해 처리 결과를 단일값으로 반환
  - 호출에 의해 실행
  - 출력 파라미터가 없음
  - SELECT로 조회만
  - 프로시저를 호출해 사용할 수 없음
  - DECLARE(필수) : 사용자 정의 함수의 명칭, 변수 등 정의하는 선언부
  - BEGIN(필수) : 트리거의 시작, 실행부
  - CONTROL : 조건문, 반복문, 삽입 순차적 처리
  - SQL : SELECT문이 삽입
  - EXCEPTION : 예외처리
  - RETURN(필수): 반환할 값이나 변수를 정의
  - END(필수) : 종료

## 26. DBMS 접속 기술

- 웹 응용 서비스의 구조
  - 사용자는 웹 서버에 접속, 웹 서버는 WAS 에게 해당 요청을 전달, WAS는 트랜잭션 언어로 변환한 후 DBMS에 전달, 데이터를 다시 웹서버로 전달해 사용자에게 도달
- DBMS 접속 기술
  - JDBC(Java Database Connectivity)
    - 썬 마이크로시스템, JAVA 언어
  - ODBC(Open database Connectivity)
    - 마이크로소프트

- 정적 SQL, 동적 SQL

|                  | **정적 SQL(Static SQL)**                     | **동적 SQL(Dynamic SQL)**                       |
| ---------------- | -------------------------------------------- | ----------------------------------------------- |
| **SQL** **구성** | 커서(Cursor)를 통한 정적 처리                | 문자열(String) 변수에 담아 동적  처리           |
| **개발 패턴**    | 커서의 범위 안에서  반복문을 활용해 SQL 작성 | NVL 함수를 사용할 필요없이 로직을 통해 SQL 작성 |
| **실행 속도**    | 빠름                                         | 느림                                            |
| **사전 검사**    | 가능                                         | 불가능 → SQL 변형 위험                          |

## ORM(Object-Relational Mapping)

- ORM의 개요
  - 객체와 관계형데이터베이스의 연결
  - 독립적이므로 재사용 및 유지보수 용이
  - 직관적이고 간단, 데이터 조작 가능
- ORM 프레임워크

| **언어** | **프레임워크**                                        |
| -------- | ----------------------------------------------------- |
| JAVA     | JPA,  Hibernate, Eclipse Link, Data Nucleus, Ebean 등 |
| C++      | ODB,  QxOrm 등                                        |
| Python   | Django,  SQL Alchemy, Storm 등                        |
| iOS      | Core  Date, Database Objects 등                       |
| .NET     | NHibernate,  Database Objects, Dapper 등              |
| PHP      | Doctrine,  Propel, RedBean 등                         |

- ORM의 한계
  - 자동으로 SQL을 작성
  - 프로젝트가 크고 복잡해질수록 적용하기 어려워짐

## 쿼리 성능 최적화

- 쿼리 성능 최적하하기 전, APM을 사용
- 실행 계획을 EXPLAIN 명령어를 통해 검토, SQL 코드와 인덱스 재구성
- 옵티마이저 : 가장 효율적으로 수행되도록 최적의 경로를 찾아 주는 모듈

- RBO(Rule Based Optimizer) vs CBO(Cost Based Optimizer)

|                 | **RBO**                             | **CBO**                              |
| --------------- | ----------------------------------- | ------------------------------------ |
| **최적화 기준** | 규칙에 정의된 우선순위              | 액세스 비용                          |
| **성능 기준**   | 개발자의 SQL 숙련도                 | 옵티마이저 알고리즘의  예측 성능     |
| **특징**        | 실행 계획 예측이 쉬움               | 성능 통계치 정보 활용, 예측이 복잡함 |
| **고려사항**    | 개발자의 규칙 이해도, 규칙의 효율성 | 비용 산출 공식의 정확성              |

- SQL 코드 및 인덱스 재구성
  - SQL 코드 재구성
    - EXISTS 활용
    - 힌트를 활용
  - 인덱스 재구성
    - IOT

## 29. 데이터 전환

- 데이터 전환의 정의
  - ETL: 추출, 변환, 적재
  - 데이터 이행 : 데이터 이관
- 데이터 전환 계획서

| **항목**                 | **세부 항목**                                                |
| ------------------------ | ------------------------------------------------------------ |
| 데이터 전환 개요         | 데이터 전환 목표  주요 성공 요인  전제조건 및 제약 조건      |
| 데이터 전환 대상 및 범위 |                                                              |
| 데이터 전환 환경 구성    | 원천 시스템 구성도(As-Is 시스템)  목적 시스템 구성도(To-Be 시스템)  전환 단계별 DISK 사용량 |
| 데이터 전환 조직 및 역할 | 데이터 전환 조직도  조직별 역할                              |
| 데이터 전환 일정         |                                                              |
| 데이터 전환 방안         | 데이터 전환 규칙  데이터 전환 절차  데이터 전환 방법  데이터 전환 설계  전환 프로그램 개발 및 테스트 계획  데이터 전환 계획  데이터 검증 방안 |
| 데이터 정비 방안         | 데이터 정비 대상 및 방법  데이터 정비 일정 및 조직           |
| 비상 계획                | 종합상황실 및 의사소통 체계                                  |
| 데이터 복구 대책         |                                                              |